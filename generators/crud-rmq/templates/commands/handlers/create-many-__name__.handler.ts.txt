import { Logger } from '@nestjs/common';
import { CommandHandler, EventBus, ICommandHandler } from '@nestjs/cqrs';
import clc from 'cli-color';
import { ContextType } from '@core/types';
import { RowValidationException } from '@core/exceptions';
import { <%= namePascal %> } from '../../schemas';
import { <%= namePascal %>CreateDto } from '../../dto';
import { <%= namePascal %>CreatedEvent } from '../../events/impl';
import { <%= namePluralPascal %>Repository } from '../../<%= namePlural %>.repository';
import { CreateMany<%= namePascal %>Command } from '../impl';

@CommandHandler(CreateMany<%= namePascal %>Command)
export class CreateMany<%= namePascal %>Handler
  implements ICommandHandler<CreateMany<%= namePascal %>Command, <%= namePascal %>[]> {
  private logger = new Logger(CreateMany<%= namePascal %>Handler.name);

  constructor(
    private readonly eventBus: EventBus,
    private readonly repository: <%= namePluralPascal %>Repository,
  ) {}

  async execute({ rows, context }: CreateMany<%= namePascal %>Command): Promise<<%= namePascal %>[]> {
    await this.checkDuplicateSlugsOrNames(rows);

    const promises = rows.map((dto, index) => {
      this.logger.debug(
        clc.greenBright(
          `Init create <%= nameCamel %> ${index + 1}/${rows.length}: ${dto.name}`,
        ),
      );

      return this.create(dto, context);
    });
    return Promise.all(promises);
  }

  private async create(
    dto: <%= namePascal %>CreateDto,
    context: ContextType,
  ): Promise<<%= namePascal %>> {
    const <%= nameCamel %> = await this.repository.save(dto);
    this.eventBus.publish(new <%= namePascal %>CreatedEvent(<%= nameCamel %>, dto, context));
    return <%= nameCamel %>;
  }

  private async checkDuplicateSlugsOrNames(rows: <%= namePascal %>CreateDto[]) {
    const { names, slugs } = rows.reduce(
      (prev, row) => {
        prev.slugs.push(row.slug);
        prev.names.push(row.name);
        return prev;
      },
      { names: [], slugs: [] },
    );

    const has = await this.repository.hasNameOrSlug(names, slugs);

    if (!has) return;

    const indexName = rows.findIndex((row) => row.name === has.name);
    if (indexName !== -1) {
      throw new RowValidationException(
        `rows.${indexName}.name`,
        'string.unique',
        'campo "nome" j치 est치 sendo utilizado!',
      );
    }

    const indexSlug = rows.findIndex((row) => row.slug === has.slug);
    if (indexSlug !== -1) {
      throw new RowValidationException(
        `rows.${indexSlug}.slug`,
        'string.unique',
        'campo "slug" j치 est치 sendo utilizado!',
      );
    }
  }
}
