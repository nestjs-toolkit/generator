import { Model } from 'mongoose';
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { EdgesResponse } from '@core/types';
import {
  <%= namePascal %>ConditionAndInput,
  <%= namePascal %>FilterInput,
} from '@core/graphql/definitions';
import { BaseRepository } from '@core/repositories';
import { <%= namePascal %> } from './schemas';
import { <%= namePascal %>CreateDto, <%= namePascal %>SearchDto } from './dto';

type Maybe<%= namePascal %> = <%= namePascal %> | undefined;
type ResultSearch = EdgesResponse<<%= namePascal %>>;

@Injectable()
export class <%= namePluralPascal %>Repository extends BaseRepository<<%= namePascal %>> {
  constructor(@InjectModel(<%= namePascal %>.name) model: Model<<%= namePascal %>>) {
    super(model);
  }

  async search(
    payload: <%= namePascal %>SearchDto,
    projection?: any,
  ): Promise<ResultSearch> {
    const conditions = {};
    const { page, perPage, sort, and, q, ids } = Object.assign(
      { page: 1, perPage: 12, sort: {}, and: {} },
      payload,
    );

    if (ids?.length) {
      conditions['_id'] = { $in: ids };
    }

    if (q) {
      conditions['name'] = { $regex: q, $options: 'i' };
    }

    const allowWhere: (keyof <%= namePascal %>ConditionAndInput)[] = [
      'name',
      'cacheKey',
      'enable',
      'position',
      'slug',
    ];

    allowWhere.forEach((col) => {
      if (and[col] !== undefined) {
        conditions[col] = and[col];
      }
    });

    return this.execWithPagination(conditions, projection, sort, perPage, page);
  }

  async hasNameOrSlug(names: string[], slugs: string[]): Promise<Maybe<%= namePascal %>> {
    return this.model.findOne({
      $or: [{ name: { $in: names } }, { slug: { $in: slugs } }],
    });
  }

  async save(dto: <%= namePascal %>CreateDto): Promise<<%= namePascal %>> {
    const <%= nameCamel %>: <%= namePascal %> = new this.model({
      name: dto.name,
      slug: dto.slug, // TODO: make slug
      position: dto.position,
      enable: dto.enable,
      thumb: 'a',
    });

    return <%= nameCamel %>.save();
  }

  async findByFilters(filter: <%= namePascal %>FilterInput): Promise<<%= namePascal %>[]> {
    const { forceAll, ids } = filter;

    if (forceAll) {
      return this.model.find();
    }

    return this.findByIds(ids);
  }

  async allEnabled(): Promise<<%= namePascal %>[]> {
    return this.model.find({ enable: true }).sort({ position: -1 }).exec();
  }
}
