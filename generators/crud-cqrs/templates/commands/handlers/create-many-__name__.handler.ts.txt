import { Logger } from '@nestjs/common';
import { CommandHandler, EventBus, ICommandHandler } from '@nestjs/cqrs';
import clc from 'cli-color';
import { ContextType } from '@core/types';
import { RowValidationException } from '@core/exceptions';
import { Scene } from '../../schemas';
import { SceneCreateDto } from '../../dto';
import { SceneCreatedEvent } from '../../events/impl';
import { ScenesRepository } from '../../scenes.repository';
import { CreateManySceneCommand } from '../impl';

@CommandHandler(CreateManySceneCommand)
export class CreateManySceneHandler
  implements ICommandHandler<CreateManySceneCommand, Scene[]> {
  private logger = new Logger(CreateManySceneHandler.name);

  constructor(
    private readonly eventBus: EventBus,
    private readonly repository: ScenesRepository,
  ) {}

  async execute({ rows, context }: CreateManySceneCommand): Promise<Scene[]> {
    await this.checkDuplicateSlugsOrNames(rows);

    const promises = rows.map((dto, index) => {
      this.logger.debug(
        clc.greenBright(
          `Init create scene ${index + 1}/${rows.length}: ${dto.name}`,
        ),
      );

      return this.create(dto, context);
    });
    return Promise.all(promises);
  }

  private async create(
    dto: SceneCreateDto,
    context: ContextType,
  ): Promise<Scene> {
    const scene = await this.repository.save(dto);
    this.eventBus.publish(new SceneCreatedEvent(scene, dto, context));
    return scene;
  }

  private async checkDuplicateSlugsOrNames(rows: SceneCreateDto[]) {
    const { names, slugs } = rows.reduce(
      (prev, row) => {
        prev.slugs.push(row.slug);
        prev.names.push(row.name);
        return prev;
      },
      { names: [], slugs: [] },
    );

    const has = await this.repository.hasNameOrSlug(names, slugs);

    if (!has) return;

    const indexName = rows.findIndex((row) => row.name === has.name);
    if (indexName !== -1) {
      throw new RowValidationException(
        `rows.${indexName}.name`,
        'string.unique',
        'campo "nome" j치 est치 sendo utilizado!',
      );
    }

    const indexSlug = rows.findIndex((row) => row.slug === has.slug);
    if (indexSlug !== -1) {
      throw new RowValidationException(
        `rows.${indexSlug}.slug`,
        'string.unique',
        'campo "slug" j치 est치 sendo utilizado!',
      );
    }
  }
}
