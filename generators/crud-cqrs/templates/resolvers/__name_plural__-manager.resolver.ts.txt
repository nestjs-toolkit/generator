import {
  Args,
  Context,
  Mutation,
  Parent,
  Query,
  ResolveField,
  Resolver,
} from '@nestjs/graphql';
import { CommandBus, QueryBus } from '@nestjs/cqrs';
import { ContextType, EdgesResponse } from '@core/types';
import { Scene } from '../schemas';
import { FindSceneQuery, SearchScenesQuery } from '../queries/impl';
import {
  SceneCreateArgs,
  SceneFindArgs,
  SceneRemoveArgs,
  SceneSearchArgs,
  SceneUpdateArgs,
} from '../dto';
import {
  CreateManySceneCommand,
  RemoveManySceneCommand,
  UpdateManySceneCommand,
} from '../commands/impl';
import {
  CreateScenePipe,
  RemoveScenePipe,
  SearchScenePipe,
  UpdateScenePipe,
} from '../pipes';

@Resolver('SceneManager')
export class ScenesManagerResolver {
  constructor(
    private readonly commandBus: CommandBus,
    private readonly queryBus: QueryBus,
  ) {}

  @Mutation('createScenesManger')
  async create(
    @Context() context: ContextType,
    @Args(CreateScenePipe) { rows }: SceneCreateArgs,
  ): Promise<EdgesResponse<Scene>> {
    const result = await this.commandBus.execute(
      new CreateManySceneCommand(rows, context),
    );

    return {
      edges: result,
      message: 'Cenário registrado com sucesso',
    };
  }

  @Query('sceneManger')
  async find(@Args() { id }: SceneFindArgs): Promise<Scene> {
    return this.queryBus.execute(new FindSceneQuery(id));
  }

  @Query('scenesManger')
  async search(
    @Args(SearchScenePipe) { params }: SceneSearchArgs,
  ): Promise<EdgesResponse<Scene>> {
    return this.queryBus.execute(new SearchScenesQuery(params));
  }

  @Mutation('updateScenesManger')
  async update(
    @Context() context: ContextType,
    @Args(UpdateScenePipe) { filter, input }: SceneUpdateArgs,
  ): Promise<EdgesResponse<Scene>> {
    const { nModified, results } = await this.commandBus.execute(
      new UpdateManySceneCommand(filter, input, context),
    );

    if (nModified === 0) {
      return {
        edges: results,
        message: 'Nenhuma cenário foi encontrada!',
      };
    }

    const message =
      nModified === 1
        ? 'Cenário atualizado com sucesso!'
        : `Foram atualizados ${nModified} cenários!`;

    return {
      edges: results,
      message,
    };
  }

  @Mutation('removeScenesManger')
  async remove(
    @Context() context: ContextType,
    @Args(RemoveScenePipe) { filter }: SceneRemoveArgs,
  ): Promise<EdgesResponse<Scene>> {
    const { nModified, results } = await this.commandBus.execute(
      new RemoveManySceneCommand(filter, context),
    );

    if (nModified === 0) {
      return {
        edges: results,
        message: 'Nenhuma cenário foi removido!',
      };
    }

    const message =
      nModified === 1
        ? 'Cenário removido com sucesso!'
        : `Foram removidos ${nModified} cenários!`;

    return {
      edges: results,
      message,
    };
  }

  @ResolveField('cacheKey')
  cacheKey(@Parent() model: Scene) {
    return `scene:${model.slug}`;
  }
}
